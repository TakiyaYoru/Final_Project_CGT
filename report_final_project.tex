\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[vietnamese]{babel}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage{graphicx}
\usepackage{array}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{xcolor}
\usepackage[most]{tcolorbox}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{times}
\usepackage{algorithm}
\usepackage{algorithmic}

% Page setup
\geometry{margin=1in}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Tổ hợp và Lý thuyết Đồ thị}
\fancyhead[R]{PNDK - Final Report}
\fancyfoot[C]{\thepage}

% Color definitions
\definecolor{titleblue}{RGB}{44,90,160}
\definecolor{lightblue}{RGB}{230,243,255}
\definecolor{releasegreen}{RGB}{46,125,50}
\definecolor{sprintblue}{RGB}{33,150,243}

% Title formatting
\titleformat{\section}{\large\bfseries\color{titleblue}}{\thesection}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\small\bfseries}{\thesubsubsection}{1em}{}

% Khung đề
\newtcolorbox{problembox}{
    title=\textbf{Đề bài}, 
    colback=white,         
    colframe=black,        
    fonttitle=\bfseries,   
    boxsep=5pt,           
    left skip=0mm,         
    right skip=0mm,        
    width=\textwidth,              
    enlarge top by=1ex,    
    enlarge bottom by=1ex, 
    before skip=1em,       
    after skip=1em         
}
% Hyperref setup
\hypersetup{
    colorlinks=true,
    linkcolor=titleblue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={},
    pdfauthor={}
}

\begin{document}

% Title Page
\begin{titlepage}
    \centering
    
    % Logo
    \includegraphics[width=0.3\textwidth]{assets/logo_umt_value.png}
    \vspace{1cm}
    
    {\LARGE\bfseries TỔ HỢP VÀ LÝ THUYẾT ĐỒ THỊ\par}
    \vspace{0.5cm}
    
    {\Large Học kỳ: Mùa hè 2025\par}
    \vspace{1.5cm}
    
    {\large Sinh viên thực hiện:\par}
    \vspace{0.5cm}
    \begin{tabular}{ll}
        2201700147 & - Phan Nguyễn Duy Kha \\
    \end{tabular}
    
    \vspace{1cm}
    {\large Giảng viên hướng dẫn: \textbf{Nguyễn Quản Bá Hồng}\par}
    
    \vfill
    
    % Release Plan Box
    \colorbox{lightblue}{%
        \begin{minipage}{0.8\textwidth}
            \centering
            \vspace{1cm}
            {\Huge\bfseries FINAL PROJECT\par}
            \vspace{0.5cm}
            {\large Đồ án cuối kỳ môn học\par}
            \vspace{1cm}
        \end{minipage}
    }
    
    \vfill
    
    {\large Khoa Công nghệ\par}
    {\large Trường Đại học Quản lý và Công nghệ TP.HCM\par}
    
\end{titlepage}

% Revision History Page
\newpage
\thispagestyle{empty}

\begin{center}
{\Huge\bfseries LỊCH SỬ SỬA ĐỔI\par}
\end{center}

\renewcommand{\arraystretch}{1.5}
\begin{center}
\begin{longtable}{|p{3cm}|p{8cm}|p{3cm}|}
\hline
\textbf{Ngày} & \textbf{Mô tả} & \textbf{Tác giả} \\
\hline
\endhead
10/07/2025 & Khởi tạo file báo cáo & Duy Kha\\
\hline
14/07/2025 & Cập nhật Project 5 & Duy Kha\\
\hline
\end{longtable}
\end{center}

% Table of Contents
\newpage
\tableofcontents

% Main Content
\newpage

\section{Tổng quan các Project}

\subsection{Project 1: Quy Nạp Toán Học và Quan Hệ Truy Hồi}

\subsection{Project 2: Đếm, Xác Suất, Banh và Hộp}

\subsection{Project: Phân Hoạch Số Nguyên}

\subsection{Project 4: Các Bài Toán Duyệt Đồ Thị và Cây}

\subsection{Project 5: Các Bài Toán Tìm Đường Đi Ngắn Nhất Trên Đồ Thị}

\newpage

\section{Project 4: Các Bài Toán Duyệt Đồ Thị và Cây}

\subsection{Bài toán 4: Chuyển đổi giữa các dạng biểu diễn đồ thị và cây}

\begin{problembox}
    \textbf{Viết chương trình C/C++, Python chuyển đổi giữa 4 dạng biểu diễn: adjacency matrix, adjacency list, extended adjacency list, adjacency map cho 3 đồ thị: đơn đồ thị, đa đồ thị, đồ thị tổng quát; \& 3 dạng biểu diễn: array of parents, first-child next-sibling, graph-based representation of trees của cây.} 
    
    Sẽ có $3 \times A_4^3 + A_2^3 = 36 + 6 = 42$ converter programs.

\end{problembox}

\textbf{Phân tích bài toán:} Bài toán yêu cầu implement tổng cộng 42 converter functions, được chia thành:

\begin{itemize}
    \item \textbf{Đồ thị:} $3 \times 4 \times 3 = 36$ converters (3 loại đồ thị × 4 dạng biểu diễn × 3 chuyển đổi mỗi dạng)
    \item \textbf{Cây:} $3 \times 2 = 6$ converters (3 dạng biểu diễn × 2 chuyển đổi mỗi dạng)
\end{itemize}

\subsubsection{Simple Graph (Đơn đồ thị) - 12 Converters}

\textbf{Định nghĩa:} Simple Graph $G = (V, E)$ là đồ thị không có cạnh song song và không có khuyên (self-loops).
\vspace{0.5cm}

\textbf{4 dạng biểu diễn:}
\begin{itemize}[label=\textbullet]
    \item 1. Adjacency Matrix (Ma trận kề)
    \item 2. Adjacency List (Danh sách kề)
    \item 3. Extended Adjacency List
    \item 4. Adjacency Map
\end{itemize}

\textbf{Converter 1: Matrix $\rightarrow$ List}

\textbf{Ý tưởng chính:} Duyệt upper triangle của ma trận đối xứng để tránh xử lý duplicate edges.

\textbf{Thuật toán:}
\begin{enumerate}
    \item Khởi tạo $n$ danh sách rỗng cho adjacency list
    \item Chỉ duyệt các vị trí $(i,j)$ với $i \leq j$ (upper triangle)
    \item Nếu $matrix[i][j] = 1$:
    \begin{itemize}
        \item Nếu $i = j$: thêm $j$ vào $adj\_list[i]$ (self-loop)
        \item Nếu $i \neq j$: thêm $j$ vào $adj\_list[i]$ và $i$ vào $adj\_list[j]$ (undirected)
    \end{itemize}
\end{enumerate}
\vspace{0.5cm}

\textbf{Converter 2: Matrix $\rightarrow$ Extended List}

\textbf{Ý tưởng chính:} Tương tự Matrix $\rightarrow$ List nhưng tạo Edge objects thay vì chỉ lưu đỉnh.

\textbf{Thuật toán:}
\begin{enumerate}
    \item Duyệt upper triangle của ma trận
    \item Với mỗi cạnh $(i,j)$ tìm được:
    \begin{itemize}
        \item Tạo $Edge(i,j)$ và thêm vào $outgoing[i]$, $incoming[j]$
        \item Nếu $i \neq j$: tạo $Edge(j,i)$ và thêm vào $outgoing[j]$, $incoming[i]$
        \item Thêm cả 2 edges vào $all\_edges$
    \end{itemize}
\end{enumerate}
\vspace{0.5cm}

\textbf{Converter 3: Matrix $\rightarrow$ Map}

\textbf{Ý tưởng chính:} Duyệt toàn bộ ma trận và thêm neighbors vào hash set.

\textbf{Thuật toán:}
\begin{enumerate}
    \item Khởi tạo $n$ hash sets rỗng
    \item Duyệt toàn bộ ma trận $(i,j)$ với $0 \leq i,j < n$
    \item Nếu $matrix[i][j] = 1$: thêm $j$ vào $adj\_map[i]$
\end{enumerate}
\vspace{0.5cm}

\textbf{Converter 4: List $\rightarrow$ Matrix}

\textbf{Ý tưởng chính:} Duyệt adjacency list và đánh dấu các vị trí tương ứng trong ma trận.

\textbf{Thuật toán:}
\begin{enumerate}
    \item Khởi tạo ma trận $n \times n$ toàn $0$
    \item Với mỗi đỉnh $u = 0, 1, \ldots, n-1$:
    \item Với mỗi neighbor $v \in adj\_list[u]$: đặt $matrix[u][v] = 1$
\end{enumerate}
\vspace{0.5cm}

\textbf{Converter 5: List $\rightarrow$ Extended List}

\textbf{Ý tưởng chính:} Tránh tạo duplicate Edge objects bằng canonical form technique.

\textbf{Thuật toán:}
\begin{enumerate}
    \item Khởi tạo $processed\_edges = \emptyset$ (hash set)
    \item Với mỗi đỉnh $u$ và neighbor $v \in adj\_list[u]$:
    \begin{itemize}
        \item Tính $edge\_key = (\min(u,v), \max(u,v))$
        \item Nếu $edge\_key \notin processed\_edges$:
        \begin{itemize}
            \item Thêm $edge\_key$ vào $processed\_edges$
            \item Tạo $Edge(u,v)$ và $Edge(v,u)$
            \item Cập nhật các cấu trúc dữ liệu
        \end{itemize}
    \end{itemize}
\end{enumerate}
\vspace{0.5cm}

\textbf{Converter 6: List $\rightarrow$ Map}

\textbf{Ý tưởng chính:} Chuyển đổi trực tiếp từ list sang set cho mỗi đỉnh.

\textbf{Thuật toán:}
\begin{enumerate}
    \item Với mỗi đỉnh $u = 0, 1, \ldots, n-1$:
    \item Chuyển $adj\_list[u]$ (list) thành $adj\_map[u]$ (set)
\end{enumerate}
\vspace{0.5cm}

\textbf{Converter 7: Extended List $\rightarrow$ Matrix}

\textbf{Ý tưởng chính:} Đơn giản nhất - duyệt tất cả edges và đánh dấu ma trận.

\textbf{Thuật toán:}
\begin{enumerate}
    \item Khởi tạo ma trận $n \times n$ toàn $0$
    \item Với mỗi $edge \in all\_edges$:
    \item Đặt $matrix[edge.source][edge.target] = 1$
\end{enumerate}
\vspace{0.5cm}

\textbf{Converter 8: Extended List $\rightarrow$ List}

\textbf{Ý tưởng chính:} Trích xuất target vertices từ outgoing edges.

\textbf{Thuật toán:}
\begin{enumerate}
    \item Với mỗi đỉnh $u = 0, 1, \ldots, n-1$:
    \item Với mỗi $edge \in outgoing[u]$:
    \item Thêm $edge.target$ vào $adj\_list[u]$ (nếu chưa có)
\end{enumerate}
\vspace{0.5cm}

\textbf{Converter 9: Extended List $\rightarrow$ Map}

\textbf{Ý tưởng chính:} Tương tự converter 8 nhưng sử dụng set thay vì list.

\textbf{Thuật toán:}
\begin{enumerate}
    \item Với mỗi đỉnh $u = 0, 1, \ldots, n-1$:
    \item Với mỗi $edge \in outgoing[u]$:
    \item Thêm $edge.target$ vào $adj\_map[u]$ (set tự động loại duplicate)
\end{enumerate}
\vspace{0.5cm}

\textbf{Converter 10: Map $\rightarrow$ Matrix}

\textbf{Ý tưởng chính:} Duyệt hash sets và đánh dấu ma trận.

\textbf{Thuật toán:}
\begin{enumerate}
    \item Khởi tạo ma trận $n \times n$ toàn $0$
    \item Với mỗi đỉnh $u = 0, 1, \ldots, n-1$:
    \item Với mỗi $v \in adj\_map[u]$: đặt $matrix[u][v] = 1$
\end{enumerate}
\vspace{0.5cm}

\textbf{Converter 11: Map $\rightarrow$ List}

\textbf{Ý tưởng chính:} Chuyển đổi trực tiếp từ set sang list cho mỗi đỉnh.

\textbf{Thuật toán:}
\begin{enumerate}
    \item Với mỗi đỉnh $u = 0, 1, \ldots, n-1$:
    \item Chuyển $adj\_map[u]$ (set) thành $adj\_list[u]$ (list)
\end{enumerate}
\vspace{0.5cm}

\textbf{Converter 12: Map $\rightarrow$ Extended List}

\textbf{Ý tưởng chính:} Chuyển đổi gián tiếp qua List để tái sử dụng algorithm đã có.

\textbf{Thuật toán:}
\begin{enumerate}
    \item Gọi $list\_graph = $ Map $\rightarrow$ List$(map\_graph)$
    \item Gọi $ext\_graph = $ List $\rightarrow$ Extended List$(list\_graph)$
    \item Trả về $ext\_graph$
\end{enumerate}



\newpage

\subsection{Bài toán 6: Tree Edit Distance}

\begin{problembox}
    \textbf{Viết chương trình C/C++, Python để giải bài toán tree edit distance problem bằng cách sử dụng: (a) Backtracking. (b) Branch bound. (c) Divide conquer. (d) Dynamic programming.} 

\end{problembox}

\textbf{Phân tích bài toán:} Tìm khoảng cách nhỏ nhất để biến đổi cây T1 thành cây T2 bằng 3 phép toán cơ bản: chèn nút (insert), xóa nút (delete), và đổi nhãn nút (relabel).

\vspace{0.5cm}
\textbf{Các loại thuật toán: }

\begin{itemize}[label=\textbullet]
    \item \textbf{Backtracking:} Duyệt tất cả các khả năng biến đổi, sử dụng đệ quy để thử tất cả các phép toán. Có thể cắt tỉa nhánh khi chi phí hiện tại vượt quá chi phí tốt nhất đã tìm thấy.
    \item \textbf{Branch and Bound:} Cải tiến của backtracking bằng cách sử dụng cận trên và cận dưới để loại bỏ các nhánh không tiềm năng, giúp giảm không gian tìm kiếm.
    \item \textbf{Divide and Conquer:} Chia bài toán lớn thành các bài toán con nhỏ hơn, giải quyết độc lập từng phần rồi kết hợp kết quả. Phù hợp với tư duy đệ quy nhưng có thể lặp lại tính toán. 
    \item \textbf{Dynamic Programming:} Sử dụng bảng lưu trữ kết quả các bài toán con để tránh tính toán lặp lại. Là phương pháp tối ưu nhất với độ phức tạp đa thức khi được cài đặt đúng cách. 
\end{itemize}


\textbf{Cài đặt Python:}
\begin{itemize}[label=\textbullet]
    \item File: \texttt{.\textbackslash code\textbackslash Project\_4\textbackslash BT6\textbackslash python}
\end{itemize}

\textbf{Cài đặt C++:}
\begin{itemize}[label=\textbullet]
    \item File: \texttt{.\textbackslash code\textbackslash Project\_4\textbackslash BT6\textbackslash c++}
\end{itemize}

\subsection{Bài toán 7: Tree traversal – Duyệt cây}

\begin{problembox}
    \textbf{Viết chương trình C/C++, Python để duyệt cây: (a) preorder traversal. (b) postorder
traversal. (c) top-down traveral. (d) bottom-up traversal.} 
\end{problembox}

\textbf{Phân tích bài toán:}

\begin{itemize}[label=\textbullet]
    \item Duyệt cây nghĩa là bạn phải ghé thăm tất cả các nút trong cây. Ví dụ, bạn có thể muốn cộng tất cả các giá trị trong cây hoặc tìm giá trị lớn nhất. Với tất cả các thao tác này, bạn sẽ cần ghé thăm từng nút của cây. (Theo programiz)
    \item Các cấu trúc dữ liệu tuyến tính như mảng, ngăn xếp , hàng đợi và danh sách liên kết chỉ có một cách để đọc dữ liệu. Nhưng một cấu trúc dữ liệu phân cấp như cây có thể được duyệt theo nhiều cách khác nhau

\end{itemize}

\textbf{Các loại duyệt cây:}

\begin{itemize}[label=\textbullet]
    \item \textbf{Preorder traversal:} Duyệt theo thứ tự gốc - trái - phải. Thích hợp để sao chép cây hoặc biểu diễn tiền tố.
    \item \textbf{Postorder traversal:} Duyệt theo thứ tự trái - phải - gốc. Thường dùng để tính toán biểu thức hoặc xóa cây.
    \item \textbf{Top-down traveral:} Duyệt theo cấp độ từ trên xuống dưới, trái sang phải (còn gọi là level-order traversal). Sử dụng hàng đợi để thực hiện.
    \item \textbf{Bottom-up traversal:} Duyệt theo cấp độ từ dưới lên trên, trái sang phải. Thực hiện giống level-order nhưng kết quả được đảo ngược.
\end{itemize}


\textbf{Cài đặt Python:}
\begin{itemize}[label=\textbullet]
    \item File: \texttt{.\textbackslash code\textbackslash Project\_4\textbackslash BT7\textbackslash python}
   \item File tổng hợp: \texttt{.\textbackslash code\textbackslash Project\_4\textbackslash BT7\textbackslash tree\_traversal.py}
\end{itemize}

\textbf{Cài đặt C++:}
\begin{itemize}[label=\textbullet]
    \item File: \texttt{.\textbackslash code\textbackslash Project\_4\textbackslash BT7\textbackslash c++}
   \item File tổng hợp: \texttt{.\textbackslash code\textbackslash Project\_4\textbackslash BT7\textbackslash tree\_traversal.cpp}
\end{itemize}



\newpage
\subsection{Bài toán 8: BFS trên đồ thị đơn (Simple Graph)}

\begin{problembox}
    \textbf{Let G = (V, E) be a finite simple graph. Implement the breadth-first search on G.} 
\end{problembox}

\textbf{Phân tích bài toán:}
\vspace{0.5cm}

\textbf{Thuật toán BFS:} 

\begin{itemize}[label=\textbullet]
    \item Là thuật toán duyệt đồ thị theo chiều rộng, bắt đầu từ một đỉnh nguồn $ s \in V $.
    \item Khám phá lần lượt tất cả các đỉnh kề của đỉnh hiện tại trước khi đi sâu hơn.
    \item Sử dụng cấu trúc dữ liệu hàng đợi (queue) để lưu trữ các đỉnh đang chờ duyệt.
    \item Đảm bảo rằng mỗi đỉnh chỉ được thăm một lần nhờ mảng đánh dấu \texttt{visited}.
\end{itemize}

\textbf{Đặc điểm đồ thị đơn (Simple graph):}
\begin{itemize}[label=\textbullet]
    \item Đồ thị vô hướng hoặc có hướng không chứa đa cạnh (tức mỗi cặp đỉnh chỉ có tối đa 1 cạnh) và không có khuyên (self-loop).
    \item Danh sách kề được lưu trữ dưới dạng mảng vector hoặc list.
\end{itemize}

\textbf{Input:}
\begin{itemize}[label=\textbullet]
    \item Đồ thị $ G = (V, E) $, biểu diễn bằng danh sách kề.
    \item Đỉnh nguồn $ s \in V $.
\end{itemize}

\textbf{Output:}
\begin{itemize}[label=\textbullet]
    \item Thứ tự các đỉnh được thăm theo BFS.
    \item Mảng khoảng cách từ đỉnh $ s $ đến các đỉnh còn lại.
\end{itemize}

\textbf{Cài đặt Python:}
\begin{itemize}[label=\textbullet]
   \item File: \texttt{.\textbackslash code\textbackslash Project\_4\textbackslash BT8\textbackslash bfs\_simple\_graph.py}
\end{itemize}

\textbf{Cài đặt C++:}
\begin{itemize}[label=\textbullet]
   \item File: \texttt{.\textbackslash code\textbackslash Project\_4\textbackslash BT8\textbackslash bfs\_simple\_graph.cpp}
\end{itemize}



\subsection{Bài toán 9: BFS trên đồ thị đa (Multigraph)}

\begin{problembox}
    \textbf{Let G = (V, E) be a finite multigraph. Implement the breadth-first search on G.} 
\end{problembox}

\textbf{Phân tích:}
\begin{itemize}[label=\textbullet]
    \item Multigraph cho phép đa cạnh giữa hai đỉnh, tức một cặp đỉnh có thể nối với nhau bởi nhiều hơn một cạnh.
    \item Có thể có khuyên (self-loop).
    \item BFS vẫn hoạt động như trên đồ thị đơn, nhờ mảng \texttt{visited} đảm bảo không thăm lại đỉnh.
    \item Đa cạnh và khuyên chỉ làm danh sách kề có thể lặp lại phần tử, không làm thay đổi logic duyệt.
\end{itemize}

\textbf{Cài đặt Python:}
\begin{itemize}[label=\textbullet]
   \item File: \texttt{.\textbackslash code\textbackslash Project\_4\textbackslash BT9\textbackslash bfs\_multigraph.py}
\end{itemize}

\textbf{Cài đặt C++:}
\begin{itemize}[label=\textbullet]
   \item File: \texttt{.\textbackslash code\textbackslash Project\_4\textbackslash BT9\textbackslash bfs\_multigraph.cpp}
\end{itemize}



\subsection{Bài toán 10: BFS trên đồ thị tổng quát (General Graph)}

\begin{problembox}
    \textbf{Let G = (V, E) be a general graph. Implement the breadth-first search on G.} 
\end{problembox}

\textbf{Phân tích:}
\begin{itemize}[label=\textbullet]
    \item Đồ thị tổng quát có thể không liên thông, gồm nhiều thành phần rời.
    \item Gồm đa cạnh, khuyên và có thể có hướng hoặc vô hướng.
    \item Thuật toán BFS cần chạy lặp lại trên tất cả các đỉnh chưa thăm để đảm bảo duyệt hết mọi thành phần.
\end{itemize}

\textbf{Cài đặt Python:}
\begin{itemize}[label=\textbullet]
   \item File: \texttt{.\textbackslash code\textbackslash Project\_4\textbackslash BT10\textbackslash bfs\_general\_graph.py}
\end{itemize}

\textbf{Cài đặt C++:}
\begin{itemize}[label=\textbullet]
   \item File: \texttt{.\textbackslash code\textbackslash Project\_4\textbackslash BT10\textbackslash bfs\_general\_graph.cpp}
\end{itemize}



\subsection{Bài toán 11: DFS trên đồ thị đơn (Simple Graph)}

\begin{problembox}
    \textbf{Let G = (V, E) be a finite simple graph. Implement the depth-first search on G.} 
\end{problembox}

\textbf{Phân tích bài toán:}
\begin{itemize}[label=\textbullet]
    \item Thuật toán duyệt theo chiều sâu, đi sâu vào từng nhánh của đồ thị trước khi quay lui.
    \item Thường sử dụng đệ quy hoặc stack để duyệt.
    \item Đảm bảo thăm mỗi đỉnh một lần nhờ mảng \texttt{visited}.
    \item Thích hợp để tìm đường đi, kiểm tra liên thông, hoặc phân tích cấu trúc đồ thị.
\end{itemize}

\textbf{Cài đặt Python:}
\begin{itemize}[label=\textbullet]
   \item File: \texttt{.\textbackslash code\textbackslash Project\_4\textbackslash BT11\textbackslash dfs\_simple\_graph.py}
\end{itemize}

\textbf{Cài đặt C++:}
\begin{itemize}[label=\textbullet]
   \item File: \texttt{.\textbackslash code\textbackslash Project\_4\textbackslash BT11\textbackslash dfs\_simple\_graph.cpp}
\end{itemize}



\subsection{Bài toán 12: DFS trên đồ thị đa (Multigraph)}

\begin{problembox}
    \textbf{Let G = (V, E) be a finite multigraph. Implement the depth-first search on G.} 
\end{problembox}

\textbf{Phân tích:}
\begin{itemize}[label=\textbullet]
    \item Đồ thị đa cạnh, có thể có khuyên.
    \item DFS vẫn giữ nguyên nguyên lý: duyệt sâu, không thăm lại đỉnh.
    \item Mảng \texttt{visited} ngăn vòng lặp do đa cạnh hoặc khuyên.
\end{itemize}

\textbf{Cài đặt Python:}
\begin{itemize}[label=\textbullet]
   \item File: \texttt{.\textbackslash code\textbackslash Project\_4\textbackslash BT12\textbackslash dfs\_multigraph.py}
\end{itemize}

\textbf{Cài đặt C++:}
\begin{itemize}[label=\textbullet]
   \item File: \texttt{.\textbackslash code\textbackslash Project\_4\textbackslash BT12\textbackslash dfs\_multigraph.cpp}
\end{itemize}


\subsection{Bài toán 13: DFS trên đồ thị tổng quát (General Graph)}

\begin{problembox}
    \textbf{Let G = (V, E) be a finite general graph. Implement the depth-first search on G.} 
\end{problembox}

\textbf{Phân tích:}
\begin{itemize}[label=\textbullet]
    \item Đồ thị tổng quát gồm nhiều thành phần rời, đa cạnh, khuyên.
    \item Cần chạy DFS nhiều lần trên các đỉnh chưa thăm để duyệt hết mọi thành phần.
    \item Tạo ra rừng DFS (DFS forest).
\end{itemize}

\textbf{Cài đặt Python:}
\begin{itemize}[label=\textbullet]
   \item File: \texttt{.\textbackslash code\textbackslash Project\_4\textbackslash BT13\textbackslash dfs\_general\_graph.py}
\end{itemize}

\textbf{Cài đặt C++:}
\begin{itemize}[label=\textbullet]
   \item File: \texttt{.\textbackslash code\textbackslash Project\_4\textbackslash BT13\textbackslash dfs\_general\_graph.cpp}
\end{itemize}



\newpage


\section{Project 5: Các Bài Toán Tìm Đường Đi Ngắn Nhất Trên Đồ Thị}

\subsection{Bài toán 14: Thuật toán Dijkstra trên Simple Graph}

\begin{problembox}
    \textbf{Let G = (V, E) be a finite simple graph. Implement the Dijkstra's algorithm to find the shortest path problem on G.}
\end{problembox}

\textbf{Phân tích bài toán:}

\textbf{INPUT:}
\begin{itemize}[label=\textbullet]
    \item Một simple graph G = (V, E)
    \item Đỉnh xuất phát (source)
    \item Đỉnh đích (target)
\end{itemize}

\textbf{OUTPUT:}
\begin{itemize}[label=\textbullet]
    \item Một simple graph G = (V, E)
    \item Đỉnh xuất phát (source)
    \item Đỉnh đích (target)
\end{itemize}

\textbf{Simple Graph:} là một đồ thị:
\begin{itemize}[label=\textbullet]
    \item Khoảng cách ngắn nhất từ đỉnh nguồn đến tất cả các đỉnh khác
    \item Đường đi tương ứng
\end{itemize}

{\centering
    \includegraphics[width=0.3\textwidth]{assets/image/simple-graph.png}
\par}
\vspace{1cm}

\textbf{Dijkstra's algorithm:} là một thuật toán giải quyết bài toán đường đi ngắn nhất từ một đỉnh đến các đỉnh còn lại của đồ thị có hướng không có cạnh mang trọng số không âm. (Nguồn: Wikipedia)

\newpage

\textbf{Các bước thuật toán:}

\begin{enumerate}
   \item \textbf{Khởi tạo:}
   \begin{itemize}[label=\textbullet]
       \item \texttt{dist[start] = 0}, \texttt{dist[other] = $\infty$}
       \item \texttt{parent[all] = -1}
       \item \texttt{visited[all] = false}
   \end{itemize}

   \item \textbf{Priority Queue:} Min-heap chứa các cặp \texttt{(khoảng\_cách, đỉnh)}

   \item \textbf{Vòng lặp chính:}
   \begin{itemize}[label=\textbullet]
       \item Lấy đỉnh \texttt{u} có khoảng cách nhỏ nhất chưa được xử lý
       \item Đánh dấu \texttt{u} đã xử lý
       \item \textbf{Relax} tất cả láng giềng \texttt{v} của \texttt{u}:
       \begin{verbatim}
if dist[u] + weight(u,v) < dist[v]:
   dist[v] = dist[u] + weight(u,v)
   parent[v] = u
   push (dist[v], v) vào priority queue
       \end{verbatim}
   \end{itemize}

   \item \textbf{Kết thúc:} Khi priority queue rỗng
\end{enumerate}

\textbf{Tính chất quan trọng:}
\begin{itemize}[label=\textbullet]
   \item \textbf{Optimal Substructure:} Đường đi ngắn nhất chứa các đường đi con ngắn nhất
   \item \textbf{Greedy Choice:} Lựa chọn tham lam luôn cho kết quả tối ưi
   \item \textbf{Không hoạt động với trọng số âm:} Thuật toán sẽ cho kết quả sai
\end{itemize}

\textbf{Độ phức tạp:}
\begin{itemize}[label=\textbullet]
   \item \textbf{Time Complexity:} O((V + E) log V)
   \begin{itemize}[label=\textendash]
       \item V lần extract-min từ priority queue: O(V log V)
       \item E lần decrease-key: O(E log V)
   \end{itemize}
   \item \textbf{Space Complexity:} O(V)
   \begin{itemize}[label=\textendash]
       \item Mảng \texttt{dist}, \texttt{parent}, \texttt{visited}: O(V)
       \item Priority queue: O(V)
   \end{itemize}
\end{itemize}

\textbf{Cài đặt Python:}
\begin{itemize}[label=\textbullet]
   \item File: \texttt{.\textbackslash code\textbackslash Project\_5\textbackslash BT14\textbackslash dijkstra\_simple\_graph.py}
\end{itemize}

\textbf{Cài đặt C++:}
\begin{itemize}[label=\textbullet]
   \item File: \texttt{.\textbackslash code\textbackslash Project\_5\textbackslash BT14\textbackslash dijkstra\_simple\_graph.cpp}
\end{itemize}
\newpage
\textbf{Format Input (simple\_graph.inp):}
\begin{verbatim}
6 7
0 1 4
1 2 8
2 5 2
0 3 3
3 4 2
4 5 3
1 4 5
\end{verbatim}

\textbf{Giải thích:}
\begin{itemize}[label=\textbullet]
   \item Dòng 1: \texttt{n m} (n = số đỉnh, m = số cạnh)
   \item m dòng tiếp: \texttt{u v w} (cạnh từ đỉnh u đến v với trọng số w)
\end{itemize}

\textbf{Output mẫu:}
\begin{verbatim}
Khoảng cách ngắn nhất từ đỉnh 0:
Đỉnh 0: 0 | Đường đi: 0
Đỉnh 1: 4 | Đường đi: 0 → 1
Đỉnh 2: 12 | Đường đi: 0 → 1 → 2
Đỉnh 3: 3 | Đường đi: 0 → 3
Đỉnh 4: 5 | Đường đi: 0 → 3 → 4
Đỉnh 5: 8 | Đường đi: 0 → 3 → 4 → 5
\end{verbatim}
\newpage
\subsection{Bài toán 15: Thuật toán Dijkstra trên Multigraph}

\begin{problembox}
    \textbf{Let G = (V, E) be a finite multigraph. Implement the Dijkstra's algorithm to find the shortest path problem on G.}
\end{problembox}


\textbf{INPUT:}
\begin{itemize}[label=\textbullet]
    \item Một multigraph G = (V, E) với trọng số không âm
    \item Đỉnh xuất phát (source)
\end{itemize}

\textbf{OUTPUT:}
\begin{itemize}[label=\textbullet]
    \item Khoảng cách ngắn nhất từ đỉnh nguồn đến tất cả các đỉnh khác
    \item Đường đi tương ứng
\end{itemize}

\textbf{Multigraph:} là một đồ thị:
\begin{itemize}[label=\textbullet]
    \item Có nhiều cạnh giữa cùng một cặp đỉnh
    \item Có thể có self-loops (cạnh từ đỉnh về chính nó)
\end{itemize}
{\centering
    \includegraphics[width=0.3\textwidth]{assets/image/multigraph.png}
\par}
\vspace{1cm}

\textbf{Các bước thuật toán:}

\begin{enumerate}
    \item \textbf{Khởi tạo:}
    \begin{itemize}[label=\textbullet]
        \item \texttt{dist[start] = 0}, \texttt{dist[other] = $\infty$}
        \item \texttt{parent[all] = -1}
        \item \texttt{visited[all] = false}
    \end{itemize}

    \item \textbf{Priority Queue:} Min-heap chứa các cặp \texttt{(khoảng\_cách, đỉnh)}

    \item \textbf{Vòng lặp chính:}
    \begin{itemize}[label=\textbullet]
        \item Lấy đỉnh \texttt{u} có khoảng cách nhỏ nhất chưa được xử lý
        \item Đánh dấu \texttt{u} đã xử lý
        \item Duyệt \textbf{tất cả cạnh} từ \texttt{u} (bao gồm multiple edges)
        \item \textbf{Bỏ qua self-loops:} \texttt{if u == v: continue}
        \item \textbf{Relax} các láng giềng \texttt{v} của \texttt{u}:
        \begin{verbatim}
if dist[u] + weight < dist[v]:
    dist[v] = dist[u] + weight
    parent[v] = u
    push (dist[v], v) vào priority queue
        \end{verbatim}
    \end{itemize}

    \item \textbf{Kết thúc:} Khi priority queue rỗng
\end{enumerate}


\textbf{Cài đặt Python:}
\begin{itemize}[label=\textbullet]
   \item File: \texttt{.\textbackslash code\textbackslash Project\_5\textbackslash BT14\textbackslash dijkstra\_multigraph.py}
\end{itemize}

\textbf{Cài đặt C++:}
\begin{itemize}[label=\textbullet]
   \item File: \texttt{.\textbackslash code\textbackslash Project\_5\textbackslash BT14\textbackslash dijkstra\_multigraph.cpp}
\end{itemize}

\textbf{Format Input (multigraph.inp):}

\begin{verbatim}
6 9
0 1 4
0 1 6
1 2 8
2 5 2
0 3 3
3 4 2
4 5 3
1 4 5
4 4 1
\end{verbatim}

\textbf{Output mẫu:}
\begin{verbatim}
Khoảng cách ngắn nhất từ đỉnh 0:
Đỉnh 0: 0 | Đường đi: 0
Đỉnh 1: 4 | Đường đi: 0 → 1
Đỉnh 2: 12 | Đường đi: 0 → 1 → 2
Đỉnh 3: 3 | Đường đi: 0 → 3
Đỉnh 4: 5 | Đường đi: 0 → 3 → 4
Đỉnh 5: 8 | Đường đi: 0 → 3 → 4 → 5
\end{verbatim}

\newpage

\subsection{Bài toán 16: Thuật toán Dijkstra trên General Graph}

\begin{problembox}
    \textbf{Let G = (V, E) be a general graph. Implement the Dijkstra's algorithm to find the shortest path problem on G.}
\end{problembox}

\textbf{Phân tích bài toán:}

\textbf{INPUT:}
\begin{itemize}[label=\textbullet]
    \item Một general graph G = (V, E)
    \item Đỉnh xuất phát (source)
\end{itemize}

\textbf{OUTPUT:}
\begin{itemize}[label=\textbullet]
    \item Khoảng cách ngắn nhất từ đỉnh nguồn đến tất cả các đỉnh khác
    \item Đường đi tương ứng (nếu thuật toán hoạt động)
\end{itemize}

\textbf{General Graph:} là đồ thị tổng quát nhất, bao gồm:
\begin{itemize}[label=\textbullet]
    \item \textbf{Directed Graph:} Đồ thị có hướng
    \item \textbf{Mixed Graph:} Kết hợp cạnh có hướng và vô hướng
    \item \textbf{Negative Weights:} Có thể có trọng số âm
    \item \textbf{Directed Cycles:} Chu trình có hướng
\end{itemize}

{\centering
    \includegraphics[width=0.8\textwidth]{assets/image/general\_graph.png}
\par}

{\centering
\textbf{General Graph}
\par}
\vspace{1cm}

\textbf {Vấn đề  với General Graph:}

\textbf{Dijkstra's Algorithm KHÔNG hoạt động với trọng số âm} vì:
\begin{itemize}[label=\textbullet]
    \item Greedy choice có thể cho kết quả sai
    \item Một khi đỉnh được đánh dấu "visited", khoảng cách không được cập nhật lại
    \item Trọng số âm có thể tạo ra đường đi ngắn hơn sau khi đỉnh đã được xử lý
\end{itemize}

\textbf{Các bước thuật toán:}

\begin{enumerate}
    \item \textbf{Kiểm tra điều kiện:}
    \begin{itemize}[label=\textbullet]
        \item Duyệt tất cả cạnh trong đồ thị
        \item Nếu phát hiện trọng số âm → dừng thuật toán
        \item Thông báo lỗi và đề xuất Bellman-Ford
    \end{itemize}

    \item \textbf{Khởi tạo (nếu không có trọng số âm):}
    \begin{itemize}[label=\textbullet]
        \item \texttt{dist[start] = 0}, \texttt{dist[other] = $\infty$}
        \item \texttt{parent[all] = -1}
        \item \texttt{visited[all] = false}
    \end{itemize}

    \item \textbf{Priority Queue:} Min-heap chứa các cặp \texttt{(khoảng\_cách, đỉnh)}

    \item \textbf{Vòng lặp chính:}
    \begin{itemize}[label=\textbullet]
        \item Lấy đỉnh \texttt{u} có khoảng cách nhỏ nhất chưa được xử lý
        \item Đánh dấu \texttt{u} đã xử lý
        \item Duyệt \textbf{chỉ cạnh đi ra} từ \texttt{u} (directed)
        \item \textbf{Relax} các láng giềng \texttt{v} của \texttt{u}:
        \begin{verbatim}
if dist[u] + weight < dist[v]:
    dist[v] = dist[u] + weight
    parent[v] = u
    push (dist[v], v) vào priority queue
        \end{verbatim}
    \end{itemize}

    \item \textbf{Kết thúc:} Khi priority queue rỗng
\end{enumerate}

\textbf{Cài đặt Python:}
\begin{itemize}[label=\textbullet]
   \item File: \texttt{.\textbackslash code\textbackslash Project\_5\textbackslash BT14\textbackslash dijkstra\_general\_graph.py}
\end{itemize}

\textbf{Cài đặt C++:}
\begin{itemize}[label=\textbullet]
   \item File: \texttt{.\textbackslash code\textbackslash Project\_5\textbackslash BT14\textbackslash dijkstra\_general\_graph.cpp}
\end{itemize}

\textbf{Format Input:}

\textbf{1. Directed Graph (general\_graph.inp):}
\begin{verbatim}
# directed
6 8
0 1 4
1 2 8
2 5 2
0 3 3
3 4 2
4 5 3
1 4 5
4 1 1
\end{verbatim}

\textbf{2. Graph với trọng số âm (negative\_graph.inp):}
\begin{verbatim}
# directed
4 5
0 1 4
1 2 -3
2 3 2
0 3 7
1 3 5
\end{verbatim}

\textbf{Output mẫu:}

\textbf{1. Directed Graph hợp lệ:}
\begin{verbatim}
Khoảng cách ngắn nhất từ đỉnh 0:
Đỉnh 0: 0 | Đường đi: 0
Đỉnh 1: 4 | Đường đi: 0 → 1
Đỉnh 2: 12 | Đường đi: 0 → 1 → 2
Đỉnh 3: 3 | Đường đi: 0 → 3
Đỉnh 4: 5 | Đường đi: 0 → 3 → 4
Đỉnh 5: 8 | Đường đi: 0 → 3 → 4 → 5
\end{verbatim}

\textbf{2. Graph với trọng số âm:}
\begin{verbatim}
Phát hiện trọng số âm tại cạnh 1→2 (trọng số: -3)
\end{verbatim}

\end{document}